import cv2
import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import os
import time


def save_annotation(self):
    """Speichert das Originalbild und die binäre Maske mit RCA/LCA Unterscheidung"""
    if self.image is not None and self.annotation_mask is not None:
        # Erstelle ein Dialogfenster für die Auswahl zwischen RCA und LCA
        vessel_type = tk.StringVar(value="LCA")  # Standardwert

        dialog = tk.Toplevel(self.root)
        dialog.title("Gefäßtyp auswählen")
        dialog.geometry("300x150")
        dialog.transient(self.root)  # Dialog im Vordergrund halten

        # Zentriere das Dialogfenster
        dialog.geometry("+%d+%d" % (
            self.root.winfo_rootx() + self.root.winfo_width() / 2 - 150,
            self.root.winfo_rooty() + self.root.winfo_height() / 2 - 75))

        # Label
        tk.Label(dialog, text="Bitte wählen Sie den Gefäßtyp:").pack(pady=10)

        # Radio Buttons
        tk.Radiobutton(dialog, text="LCA (Left Coronary Artery)", variable=vessel_type, value="LCA").pack()
        tk.Radiobutton(dialog, text="RCA (Right Coronary Artery)", variable=vessel_type, value="RCA").pack()

        # Speichern Variable für Dialog-Ergebnis
        result = {"confirmed": False}

        def on_confirm():
            result["confirmed"] = True
            dialog.destroy()

        def on_cancel():
            dialog.destroy()

        # Buttons
        button_frame = tk.Frame(dialog)
        button_frame.pack(pady=10)
        tk.Button(button_frame, text="Bestätigen", command=on_confirm).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Abbrechen", command=on_cancel).pack(side=tk.LEFT, padx=5)

        # Warte auf Dialog
        dialog.wait_window()

        # Wenn der Benutzer abgebrochen hat, beende die Funktion
        if not result["confirmed"]:
            return

        # Speicherverzeichnis festlegen
        save_dir = r"D:\Selina\phD\AngioNet"
        os.makedirs(save_dir, exist_ok=True)

        # Verwende den ursprünglichen Bildnamen wenn vorhanden, sonst einen Zeitstempel
        if hasattr(self, 'current_image_path'):
            original_filename = os.path.splitext(os.path.basename(self.current_image_path))[0]
            save_filename = f"{original_filename}_{vessel_type.get()}_{time.strftime('%Y%m%d')}"
        else:
            save_filename = f"annotation_{vessel_type.get()}_{time.strftime('%Y%m%d_%H%M%S')}"

        base_path = os.path.join(save_dir, save_filename)

        # Speichere Originalbild
        cv2.imwrite(f"{base_path}_original.png", self.image)
        print(f"Originalbild gespeichert als: {base_path}_original.png")

        # Erstelle und speichere binäre Maske (weiße Gefäße auf schwarzem Hintergrund)
        binary_mask = np.zeros_like(self.image)
        binary_mask[self.annotation_mask > 0] = 255  # Gefäße = weiß (255)
        cv2.imwrite(f"{base_path}_mask.png", binary_mask)
        print(f"Binäre Maske gespeichert als: {base_path}_mask.png")

        # Speichere Visualisierung für Qualitätskontrolle mit transparentem Grün
        visualization = cv2.cvtColor(self.image, cv2.COLOR_GRAY2BGR)

        # Erstelle separate Layer für Annotationen mit transparentem Grün
        overlay = np.zeros_like(visualization, dtype=np.float32)
        overlay[self.annotation_mask > 0] = [0, 1, 0]  # Grün für Annotationen

        # Kombiniere die Layer mit 50% Transparenz
        visualization = cv2.addWeighted(visualization, 1, (overlay * 255).astype(np.uint8), 0.5, 0)

        cv2.imwrite(f"{base_path}_overlay.png", visualization)
        print(f"Visualisierung gespeichert als: {base_path}_overlay.png")

        # Zeige Erfolgsmeldung
        tk.messagebox.showinfo(
            "Speicherung erfolgreich",
            f"Bilder wurden gespeichert als:\n\n"
            f"• {save_filename}_original.png\n"
            f"• {save_filename}_mask.png\n"
            f"• {save_filename}_overlay.png\n\n"
            f"Gefäßtyp: {vessel_type.get()}\n"
            f"Speicherort: {save_dir}"
        )
class VesselAnnotator:

    def show_welcome_dialog(self):
        """Zeigt einen Willkommensdialog mit Startoptionen"""
        welcome = tk.Toplevel(self.root)
        welcome.title("Gefäß-Annotationstool")
        welcome.geometry("500x400")
        welcome.transient(self.root)
        welcome.grab_set()  # Modal-Dialog

        # Zentriere das Fenster
        welcome.geometry("+%d+%d" % (
            self.root.winfo_rootx() + self.root.winfo_width() // 2 - 250,
            self.root.winfo_rooty() + self.root.winfo_height() // 2 - 200))

        # Überschrift
        tk.Label(welcome, text="Gefäß-Annotationstool",
                 font=('Arial', 14, 'bold')).pack(pady=20)

        # Beschreibung
        description = """
        Beginne, indem du einen ganzen Ordner oder ein einzelnes Bild lädst.
     
        Dieses Tool besitzt folgende Funktionen:
        
        • Mit dem Mausrad kannst du Zoomen
        • Mit Shift + Mausrad kannst du dich durch die Bilder klicken oder 
        verwende die Pfeiltasten
        • Halte die rechte Maustaste gedrückt, um die Ansicht des Fensters zu verschieben
        • Mit dem Klick auf "Rückgängig" löscht sich dein letzter Strich
        • Mit dem Klick auf "Zurücksetzen" löscht sich deine ganze Annotation
        • Speichere die Annotationen unter "Speichern"
        """
        tk.Label(welcome, text=description, justify=tk.LEFT).pack(padx=20, pady=10)

        # Frame für die Buttons
        button_frame = tk.Frame(welcome)
        button_frame.pack(pady=20)

        def load_dir_and_close():
            welcome.destroy()
            self.load_directory()

        def load_image_and_close():
            welcome.destroy()
            self.load_image()

        # Buttons
        tk.Button(button_frame, text="Ordner mit Bildern laden",
                  command=load_dir_and_close, width=20).pack(pady=5)
        tk.Button(button_frame, text="Einzelnes Bild laden",
                  command=load_image_and_close, width=20).pack(pady=5)


    def save_annotation(self):
        """Speichert das Originalbild und die binäre Maske mit RCA/LCA Unterscheidung"""
        if self.image is not None and self.annotation_mask is not None:
            # Erstelle ein Dialogfenster für die Auswahl zwischen RCA und LCA
            vessel_type = tk.StringVar(value="LCA")  # Standardwert

            dialog = tk.Toplevel(self.root)
            dialog.title("Gefäßtyp auswählen")
            dialog.geometry("300x150")
            dialog.transient(self.root)  # Dialog im Vordergrund halten

            # Zentriere das Dialogfenster
            dialog.geometry("+%d+%d" % (
                self.root.winfo_rootx() + self.root.winfo_width() / 2 - 150,
                self.root.winfo_rooty() + self.root.winfo_height() / 2 - 75))

            # Label
            tk.Label(dialog, text="Bitte wählen Sie den Gefäßtyp:").pack(pady=10)

            # Radio Buttons
            tk.Radiobutton(dialog, text="LCA (Left Coronary Artery)", variable=vessel_type, value="LCA").pack()
            tk.Radiobutton(dialog, text="RCA (Right Coronary Artery)", variable=vessel_type, value="RCA").pack()

            # Speichern Variable für Dialog-Ergebnis
            result = {"confirmed": False}

            def on_confirm():
                result["confirmed"] = True
                dialog.destroy()

            def on_cancel():
                dialog.destroy()

            # Buttons
            button_frame = tk.Frame(dialog)
            button_frame.pack(pady=10)
            tk.Button(button_frame, text="Bestätigen", command=on_confirm).pack(side=tk.LEFT, padx=5)
            tk.Button(button_frame, text="Abbrechen", command=on_cancel).pack(side=tk.LEFT, padx=5)

            # Warte auf Dialog
            dialog.wait_window()

            # Wenn der Benutzer abgebrochen hat, beende die Funktion
            if not result["confirmed"]:
                return

            # Speicherverzeichnis festlegen
            save_dir = r"D:\Selina\phD\AngioNet\Annotationen"
            os.makedirs(save_dir, exist_ok=True)

            # Verwende den ursprünglichen Bildnamen wenn vorhanden, sonst einen Zeitstempel
            if hasattr(self, 'current_image_path'):
                original_filename = os.path.splitext(os.path.basename(self.current_image_path))[0]
                save_filename = f"{original_filename}_{vessel_type.get()}_{time.strftime('%Y%m%d')}"
            else:
                save_filename = f"annotation_{vessel_type.get()}_{time.strftime('%Y%m%d_%H%M%S')}"

            base_path = os.path.join(save_dir, save_filename)

            # Speichere Originalbild
            cv2.imwrite(f"{base_path}_original.png", self.image)
            print(f"Originalbild gespeichert als: {base_path}_original.png")

            # Erstelle und speichere binäre Maske (weiße Gefäße auf schwarzem Hintergrund)
            binary_mask = np.zeros_like(self.image)
            binary_mask[self.annotation_mask > 0] = 255  # Gefäße = weiß (255)
            cv2.imwrite(f"{base_path}_mask.png", binary_mask)
            print(f"Binäre Maske gespeichert als: {base_path}_mask.png")

            # Speichere Visualisierung für Qualitätskontrolle mit transparentem Grün
            visualization = cv2.cvtColor(self.image, cv2.COLOR_GRAY2BGR)

            # Erstelle separate Layer für Annotationen mit transparentem Grün
            overlay = np.zeros_like(visualization, dtype=np.float32)
            overlay[self.annotation_mask > 0] = [0, 1, 0]  # Grün für Annotationen

            # Kombiniere die Layer mit 50% Transparenz
            visualization = cv2.addWeighted(visualization, 1, (overlay * 255).astype(np.uint8), 0.5, 0)

            cv2.imwrite(f"{base_path}_overlay.png", visualization)
            print(f"Visualisierung gespeichert als: {base_path}_overlay.png")

            # Zeige Erfolgsmeldung
            tk.messagebox.showinfo(
                "Speicherung erfolgreich",
                f"Bilder wurden gespeichert als:\n\n"
                f"• {save_filename}_original.png\n"
                f"• {save_filename}_mask.png\n"
                f"• {save_filename}_overlay.png\n\n"
                f"Gefäßtyp: {vessel_type.get()}\n"
                f"Speicherort: {save_dir}"
            )

    def on_horizontal_scroll(self, event):
        """Handhabt horizontales Scrollen für die Bildnavigation"""
        if not self.image_files:
            return

        # Bestimme die Scroll-Richtung
        if event.num == 4 or (hasattr(event, 'delta') and event.delta > 0):
            # Scroll nach links (vorheriges Bild)
            if self.current_image_index > 0:
                self.current_image_index -= 1
                self.load_current_image()
        else:
            # Scroll nach rechts (nächstes Bild)
            if self.current_image_index < len(self.image_files) - 1:
                self.current_image_index += 1
                self.load_current_image()

    def __init__(self, window_title="Arterien Annotator"):
        self.root = tk.Tk()
        self.root.title(window_title)

        # Startgröße und Position
        window_width = 1000
        window_height = 800
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.root.geometry(f"{window_width}x{window_height}+{x}+{y}")

        # Hauptframe
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        # Buttons
        self.button_frame = tk.Frame(self.main_frame)
        self.button_frame.pack(side=tk.TOP, fill=tk.X)

        # Erste Reihe von Buttons
        self.first_button_row = tk.Frame(self.button_frame)
        self.first_button_row.pack(fill=tk.X)

        tk.Button(self.first_button_row, text="Ordner laden", command=self.load_directory).pack(side=tk.LEFT, padx=5)
        tk.Button(self.first_button_row, text="Bild laden", command=self.load_image).pack(side=tk.LEFT, padx=5)
        tk.Button(self.first_button_row, text="Speichern", command=self.save_annotation).pack(side=tk.LEFT, padx=5)
        tk.Button(self.first_button_row, text="Rückgängig", command=self.undo_last).pack(side=tk.LEFT, padx=5)
        tk.Button(self.first_button_row, text="Zurücksetzen", command=self.clear_annotation).pack(side=tk.LEFT, padx=5)

        # Zweite Reihe von Buttons für Navigation
        self.second_button_row = tk.Frame(self.button_frame)
        self.second_button_row.pack(fill=tk.X)

        self.prev_button = tk.Button(self.second_button_row, text="← Vorheriges Bild", command=self.prev_image,
                                     state=tk.DISABLED)
        self.prev_button.pack(side=tk.LEFT, padx=5)

        self.next_button = tk.Button(self.second_button_row, text="Nächstes Bild →", command=self.next_image,
                                     state=tk.DISABLED)
        self.next_button.pack(side=tk.LEFT, padx=5)

        self.image_label = tk.Label(self.second_button_row, text="Bild: 0/0")
        self.image_label.pack(side=tk.LEFT, padx=5)

        # Zoom Controls
        tk.Label(self.button_frame, text="Zoom:").pack(side=tk.LEFT, padx=5)
        self.zoom_scale = tk.Scale(self.button_frame, from_=100, to=600, orient=tk.HORIZONTAL,
                                   command=self.on_zoom_change, length=100)
        self.zoom_scale.set(100)
        self.zoom_scale.pack(side=tk.LEFT, padx=5)

        # Stift-Größe
        self.pen_size = tk.IntVar(value=3)
        tk.Label(self.button_frame, text="Stift-Größe:").pack(side=tk.LEFT, padx=5)
        tk.Scale(self.button_frame, from_=1, to=10, orient=tk.HORIZONTAL,
                 variable=self.pen_size, length=100).pack(side=tk.LEFT, padx=5)

        # Frame für Canvas und Scrollbars
        self.canvas_frame = tk.Frame(self.main_frame)
        self.canvas_frame.pack(fill=tk.BOTH, expand=True)
        self.canvas_frame.grid_rowconfigure(0, weight=1)
        self.canvas_frame.grid_columnconfigure(0, weight=1)

        # Canvas für das Bild
        self.canvas = tk.Canvas(self.canvas_frame, cursor="cross")
        self.canvas.grid(row=0, column=0, sticky="nsew")

        # Scrollbar-Konfiguration
        self.h_scroll = tk.Scrollbar(self.canvas_frame, orient=tk.HORIZONTAL)
        self.h_scroll.grid(row=1, column=0, sticky="ew")
        self.h_scroll.config(command=self.canvas.xview)

        self.v_scroll = tk.Scrollbar(self.canvas_frame, orient=tk.VERTICAL)
        self.v_scroll.grid(row=0, column=1, sticky="ns")
        self.v_scroll.config(command=self.canvas.yview)

        # Canvas-Konfiguration
        self.canvas.config(
            xscrollcommand=self.h_scroll.set,
            yscrollcommand=self.v_scroll.set,
            xscrollincrement=5,
            yscrollincrement=5
        )

        # Stellen Sie sicher, dass der Canvas-Frame sich korrekt ausdehnt
        self.canvas_frame.grid_rowconfigure(0, weight=1)
        self.canvas_frame.grid_columnconfigure(0, weight=1)

        # Minimale Fenstergröße setzen
        self.root.minsize(600, 600)

        # Bildvariablen
        self.image = None
        self.photo = None
        self.annotation_mask = None
        self.current_stroke_mask = None
        self.annotation_history = []
        self.zoom_factor = 1.0
        self.drawing = False
        self.last_x = None
        self.last_y = None

        # Variablen für Bilderliste
        self.image_files = []
        self.current_image_index = -1
        self.current_directory = None
        self.panning = False
        self.pan_start_x = 0
        self.pan_start_y = 0

        # Event Bindings
        self.canvas.bind("<Button-1>", self.start_draw)
        self.canvas.bind("<B1-Motion>", self.draw)
        self.canvas.bind("<ButtonRelease-1>", self.stop_draw)
        self.canvas.bind("<MouseWheel>", self.on_mousewheel)
        self.canvas.bind("<Button-4>", self.on_mousewheel)
        self.canvas.bind("<Button-5>", self.on_mousewheel)
        self.canvas.bind("<Configure>", self.center_image)
        self.canvas.bind("<Button-3>", self.start_pan)
        self.canvas.bind("<B3-Motion>", self.pan)
        self.canvas.bind("<ButtonRelease-3>", self.stop_pan)

        # Tastatur-Bindings für Navigation
        self.root.bind("<Left>", self.prev_image)
        self.root.bind("<Right>", self.next_image)

        # Fenster in den Vordergrund
        self.root.lift()
        self.root.attributes('-topmost', True)
        self.root.after_idle(self.root.attributes, '-topmost', False)

        # Erweiterte Event Bindings für horizontales Scrollen
        self.canvas.bind("<Shift-MouseWheel>", self.on_horizontal_scroll)  # Windows
        self.canvas.bind("<Shift-Button-4>", self.on_horizontal_scroll)  # Linux scroll up
        self.canvas.bind("<Shift-Button-5>", self.on_horizontal_scroll)  # Linux scroll down

        # Nach der Initialisierung Willkommensdialog zeigen
        self.root.after(100, self.show_welcome_dialog)

    def enhance_image(self, image):
        """Verbessert die Bildqualität durch Butterworth High-Pass Filter"""

        def butterworth_high_pass(image, cutoff, order, boost=1.2, detail_weight=0.3):
            """
            Erweiterter Butterworth High-Pass Filter
            cutoff: Grenzfrequenz (je niedriger, desto mehr Details)
            order: Steilheit des Filters
            boost: Verstärkung des Originalbildes
            detail_weight: Gewichtung der gefilterten Details
            """
            # Fourier Transform
            f = np.fft.fft2(image)
            fshift = np.fft.fftshift(f)

            # Erstelle Butterworth High-Pass Filter
            rows, cols = image.shape
            crow, ccol = rows // 2, cols // 2
            y, x = np.ogrid[-crow:rows - crow, -ccol:cols - ccol]
            d = np.sqrt(x * x + y * y)
            butterworth = 1 / (1 + (cutoff / d) ** (2 * order))

            # Wende Filter an
            fshift_filtered = fshift * butterworth
            f_ishift = np.fft.ifftshift(fshift_filtered)
            img_filtered = np.fft.ifft2(f_ishift)
            img_filtered = np.abs(img_filtered)

            # Normalisiere
            img_filtered = cv2.normalize(img_filtered, None, 0, 255, cv2.NORM_MINMAX)

            # Kombiniere mit Original mit anpassbaren Parametern
            sharpened = cv2.addWeighted(image, boost, img_filtered.astype(np.uint8), detail_weight, 0)

            # Optional: Zusätzliche Kontraststeigerung durch Histogram Stretching
            min_val = np.min(sharpened)
            max_val = np.max(sharpened)
            sharpened = ((sharpened - min_val) / (max_val - min_val) * 255).astype(np.uint8)

            return sharpened

        # Wende den High-Pass Filter mit den Standard-Parametern an
        return butterworth_high_pass(image, cutoff=10, order=2, boost=1.2, detail_weight=0.3)

    def get_image_position(self):
        """Ermittelt die aktuelle Position des Bildes im Canvas"""
        bbox = self.canvas.bbox("all")
        if not bbox:
            return 0, 0
        return bbox[0], bbox[1]

    def canvas_to_image_coords(self, x, y):
        """Konvertiert Canvas-Koordinaten zu Bildkoordinaten"""
        # Scrollposition berücksichtigen
        canvas_x = self.canvas.canvasx(x)
        canvas_y = self.canvas.canvasy(y)

        # Bildposition berücksichtigen
        img_x, img_y = self.get_image_position()
        canvas_x -= img_x
        canvas_y -= img_y

        # Zoom-Faktor berücksichtigen
        image_x = int(canvas_x / self.zoom_factor)
        image_y = int(canvas_y / self.zoom_factor)

        # Auf Bildgrenzen beschränken
        image_x = max(0, min(image_x, self.image.shape[1] - 1))
        image_y = max(0, min(image_y, self.image.shape[0] - 1))

        return image_x, image_y

    def center_image(self, event=None):
        """Zentriert das Bild im Canvas"""
        if self.photo is None:
            return

        # Aktuelle Canvas-Größe
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        if canvas_width <= 1 or canvas_height <= 1:
            self.root.after(100, self.center_image)
            return

        # Bildgröße
        photo_width = self.photo.width()
        photo_height = self.photo.height()

        # Berechne die Position für Zentrierung
        x = (canvas_width - photo_width) // 2 if canvas_width > photo_width else 0
        y = (canvas_height - photo_height) // 2 if canvas_height > photo_height else 0

        # Bild neu positionieren
        self.canvas.delete("all")
        self.canvas.create_image(x, y, image=self.photo, anchor=tk.NW, tags="image")

        # Scrollregion setzen
        scroll_width = max(canvas_width, photo_width)
        scroll_height = max(canvas_height, photo_height)
        self.canvas.config(scrollregion=(0, 0, scroll_width, scroll_height))

    def update_canvas(self, center=True):
        """Aktualisiert die Canvas-Anzeige"""
        if self.image is not None:
            # Erstelle Basis-Display
            display = cv2.cvtColor(self.image, cv2.COLOR_GRAY2BGR)

            # Erstelle Layer für Annotationen
            annotation_layer = np.zeros_like(display, dtype=np.float32)

            if self.current_stroke_mask is not None:
                annotation_layer[self.current_stroke_mask > 0] = [0, 1, 0]

            if self.annotation_mask is not None:
                annotation_layer[self.annotation_mask > 0] = [0, 0.5, 0]

            # Kombiniere Layer
            display = cv2.addWeighted(display, 1, (annotation_layer * 255).astype(np.uint8), 0.5, 0)

            # Zoom anwenden
            h, w = display.shape[:2]
            new_size = (int(w * self.zoom_factor), int(h * self.zoom_factor))

            if self.zoom_factor > 1:
                display = cv2.resize(display, new_size, interpolation=cv2.INTER_CUBIC)
            else:
                display = cv2.resize(display, new_size, interpolation=cv2.INTER_AREA)

            # Konvertiere für Tkinter
            display = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
            self.photo = ImageTk.PhotoImage(image=Image.fromarray(display))

            # Canvas aktualisieren
            self.center_image()

    def on_mousewheel(self, event):
        """Verbesserte Mausrad-Zoom Funktion mit Shift-Modifikator Check"""
        if self.image is None:
            return

        # Wenn Shift gedrückt ist, nicht zoomen
        if event.state & 0x1:  # Shift is pressed
            return

        # Aktuelle Mausposition relativ zum Canvas
        mouse_x = self.canvas.canvasx(event.x)
        mouse_y = self.canvas.canvasy(event.y)

        # Zoom-Faktor ändern
        old_zoom = self.zoom_scale.get()
        if event.num == 4 or event.delta > 0:  # Zoom in
            new_zoom = min(old_zoom + 10, 600)
        else:  # Zoom out
            new_zoom = max(old_zoom - 10, 100)

        # Nur updaten wenn sich der Zoom tatsächlich geändert hat
        if new_zoom != old_zoom:
            self.zoom_scale.set(new_zoom)  # Dies triggert on_zoom_change

    def on_zoom_change(self, value):
        """Verbesserte Zoom-Funktion mit Debouncing"""
        if self.image is None:
            return

        if hasattr(self, '_zoom_after_id'):
            self.root.after_cancel(self._zoom_after_id)

        def delayed_zoom():
            old_zoom = self.zoom_factor
            self.zoom_factor = int(value) / 100

            # Nur updaten wenn sich der Zoom tatsächlich geändert hat
            if old_zoom != self.zoom_factor:
                self.update_canvas(center=True)

        # Verzögere das Zoom-Update um 50ms für Debouncing
        self._zoom_after_id = self.root.after(50, delayed_zoom)

    def load_directory(self):
        """Lädt einen Ordner mit Bildern"""
        directory = filedialog.askdirectory(title="Wähle einen Ordner mit Bildern")
        if directory:
            self.current_directory = directory
            self.image_files = []

            # Suche nach Bilddateien im ausgewählten Ordner
            valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.tiff', '.bmp')
            for file in sorted(os.listdir(directory)):
                if file.lower().endswith(valid_extensions):
                    self.image_files.append(os.path.join(directory, file))

            if self.image_files:
                self.current_image_index = 0
                self.load_current_image()
                self.update_navigation_buttons()
                tk.messagebox.showinfo("Ordner geladen",
                                       f"{len(self.image_files)} Bilder gefunden.\n"
                                       "Verwenden Sie die Navigationstasten oder die Pfeiltasten (← →) "
                                       "um zwischen den Bildern zu wechseln.")
            else:
                tk.messagebox.showwarning("Keine Bilder",
                                          "Keine Bilder im ausgewählten Ordner gefunden.")

    def load_current_image(self):
        """Lädt das aktuelle Bild und zentriert es"""
        if 0 <= self.current_image_index < len(self.image_files):
            file_path = self.image_files[self.current_image_index]
            self.load_image_from_path(file_path)
            self.update_navigation_buttons()
            # Explizites Zentrieren nach dem Laden
            self.root.after(100, self.center_image)

    def load_image_from_path(self, file_path):
        """Lädt ein Bild von einem Pfad"""
        self.image = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)
        if self.image is None:
            print(f"Fehler beim Laden des Bildes: {file_path}")
            return

        # Auf 512x512 skalieren
        self.image = cv2.resize(self.image, (512, 512))
        self.image = self.enhance_image(self.image)

        # Annotation initialisieren
        self.annotation_mask = np.zeros_like(self.image)
        self.annotation_history = [self.annotation_mask.copy()]

        # Aktuellen Zoom-Level speichern
        current_zoom = self.zoom_scale.get()

        # Bild anzeigen mit bestehendem Zoom
        self.current_image_path = file_path
        self.zoom_factor = current_zoom / 100  # Zoom-Faktor beibehalten
        self.update_canvas()

    def on_scroll(self, event):
        """Handhabt vertikales Scrollen für die Bildnavigation"""
        if not self.image_files:
            return

        # Aktuellen Zoom-Level speichern
        current_zoom = self.zoom_scale.get()

        # Scroll-Richtung bestimmen und Bild laden
        if event.num == 4 or (hasattr(event, 'delta') and event.delta > 0):
            # Scroll nach oben (vorheriges Bild)
            if self.current_image_index > 0:
                self.current_image_index -= 1
                self.load_current_image()
                # Zoom-Level wiederherstellen
                self.zoom_scale.set(current_zoom)
                self.zoom_factor = current_zoom / 100
                self.update_canvas()
        else:
            # Scroll nach unten (nächstes Bild)
            if self.current_image_index < len(self.image_files) - 1:
                self.current_image_index += 1
                self.load_current_image()
                # Zoom-Level wiederherstellen
                self.zoom_scale.set(current_zoom)
                self.zoom_factor = current_zoom / 100
                self.update_canvas()

    def next_image(self, event=None):
        """Lädt das nächste Bild"""
        if self.current_image_index < len(self.image_files) - 1:
            # Aktuellen Zoom-Level speichern
            current_zoom = self.zoom_scale.get()

            self.current_image_index += 1
            self.load_current_image()

            # Zoom-Level wiederherstellen
            self.zoom_scale.set(current_zoom)
            self.zoom_factor = current_zoom / 100
            self.update_canvas()

    def prev_image(self, event=None):
        """Lädt das vorherige Bild"""
        if self.current_image_index > 0:
            # Aktuellen Zoom-Level speichern
            current_zoom = self.zoom_scale.get()

            self.current_image_index -= 1
            self.load_current_image()

            # Zoom-Level wiederherstellen
            self.zoom_scale.set(current_zoom)
            self.zoom_factor = current_zoom / 100
            self.update_canvas()

    def update_navigation_buttons(self):
        """Aktualisiert den Status der Navigationsbuttons und des Labels"""
        if self.image_files:
            self.prev_button.config(state=tk.NORMAL if self.current_image_index > 0 else tk.DISABLED)
            self.next_button.config(
                state=tk.NORMAL if self.current_image_index < len(self.image_files) - 1 else tk.DISABLED)
            self.image_label.config(text=f"Bild: {self.current_image_index + 1}/{len(self.image_files)}")
        else:
            self.prev_button.config(state=tk.DISABLED)
            self.next_button.config(state=tk.DISABLED)
            self.image_label.config(text="Bild: 0/0")

    def next_image(self, event=None):
        """Lädt das nächste Bild"""
        if self.current_image_index < len(self.image_files) - 1:
            self.current_image_index += 1
            self.load_current_image()

    def prev_image(self, event=None):
        """Lädt das vorherige Bild"""
        if self.current_image_index > 0:
            self.current_image_index -= 1
            self.load_current_image()

    def load_image(self):
        """Lädt ein einzelnes Bild über den Dateidialog"""
        file_path = filedialog.askopenfilename(
            filetypes=[("Image files", "*.png *.jpg *.jpeg *.tif *.tiff *.bmp")])

        if file_path:
            # Zurücksetzen der Bilderliste
            self.image_files = []
            self.current_image_index = -1
            self.current_directory = None

            # Lade das ausgewählte Bild
            self.load_image_from_path(file_path)
            self.update_navigation_buttons()

    def start_draw(self, event):
        """Startet den Zeichenvorgang"""
        self.drawing = True
        x, y = self.canvas_to_image_coords(event.x, event.y)
        self.last_x, self.last_y = x, y

        # Neue Maske für den aktuellen Strich
        self.current_stroke_mask = np.zeros_like(self.image)

    def draw(self, event):
        """Zeichnet die Annotation"""
        if self.drawing and self.image is not None:
            x, y = self.canvas_to_image_coords(event.x, event.y)

            # Zeichne Linie in die temporäre Maske
            cv2.line(self.current_stroke_mask,
                     (self.last_x, self.last_y),
                     (x, y),
                     255,  # Weiß
                     self.pen_size.get())

            self.last_x, self.last_y = x, y

            # Update Anzeige ohne Neuzentrierung
            self.update_canvas(center=False)

    def stop_draw(self, event):
        """Beendet den Zeichenvorgang und behält die Zentrierung bei"""
        if self.drawing:
            self.drawing = False

            if self.current_stroke_mask is not None:
                # Kombiniere aktuellen Strich mit bisheriger Annotation
                combined_mask = cv2.bitwise_or(self.annotation_mask, self.current_stroke_mask)

                # Finde Konturen
                contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                # Erstelle neue Maske für gefüllte Konturen
                filled_mask = np.zeros_like(self.image)
                for contour in contours:
                    cv2.drawContours(filled_mask, [contour], -1, 255, -1)

                # Aktualisiere Hauptmaske
                self.annotation_mask = filled_mask.copy()
                self.annotation_history.append(self.annotation_mask.copy())
                self.current_stroke_mask = None

                # Update mit Zentrierung
                self.update_canvas()

    def undo_last(self):
        """Macht den letzten Strich rückgängig"""
        if len(self.annotation_history) > 1:
            self.annotation_history.pop()  # Entferne den letzten Zustand
            self.annotation_mask = self.annotation_history[-1].copy()  # Stelle vorherigen Zustand wieder her
            self.current_stroke_mask = None
            self.update_canvas(center=False)  # Update ohne Neuzentrierung

    def clear_annotation(self):
        """Löscht alle Annotationen"""
        if self.image is not None:
            self.annotation_mask = np.zeros_like(self.image)
            self.current_stroke_mask = None
            self.annotation_history = [self.annotation_mask.copy()]  # Zurücksetzen der Historie
            self.update_canvas(center=True)

    def run(self):
        """Startet die Anwendung"""
        self.root.mainloop()

    def start_pan(self, event):
        """Startet das Verschieben des Bildes mit der rechten Maustaste"""
        self.panning = True
        self.pan_start_x = event.x
        self.pan_start_y = event.y
        self.canvas.config(cursor="fleur")  # Ändert den Cursor zum Verschiebe-Symbol

    def pan(self, event):
        """Verschiebt das Bild während die rechte Maustaste gedrückt ist"""
        if self.panning and self.photo:
            # Berechne die Verschiebung
            delta_x = (self.pan_start_x - event.x) / self.canvas.winfo_width()
            delta_y = (self.pan_start_y - event.y) / self.canvas.winfo_height()

            # Aktuelle Scroll-Position
            current_x = self.canvas.xview()[0]
            current_y = self.canvas.yview()[0]

            # Verschiebe das Bild
            self.canvas.xview_moveto(current_x + delta_x)
            self.canvas.yview_moveto(current_y + delta_y)

            # Aktualisiere Startposition
            self.pan_start_x = event.x
            self.pan_start_y = event.y

    def stop_pan(self, event):
        """Beendet das Verschieben des Bildes"""
        self.panning = False
        self.canvas.config(cursor="cross")  # Setzt den Cursor zurück zum Kreuz


def main():
    print("Annotations-Tool wird gestartet...")
    annotator = VesselAnnotator()
    annotator.run()

    # Lade das Bild automatisch beim Start
    image_path = "D:\Selina\phD\AngioNet\PNG\1 Koronare GE-KHK\400913\400913_SER00001_I00001_0000.png"
    initial_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if initial_image is not None:
        # Auf 512x512 skalieren
        initial_image = cv2.resize(initial_image, (512, 512))

        # Bildverbesserung anwenden
        annotator.image = annotator.enhance_image(initial_image)

        # Annotation initialisieren
        annotator.annotation_mask = np.zeros_like(annotator.image)
        annotator.annotation_history = [annotator.annotation_mask.copy()]
        annotator.update_canvas(center=True)
        print(f"Bild wurde geladen und verbessert: {image_path}")
    else:
        print(f"Fehler beim Laden des Bildes: {image_path}")

    annotator.run()


if __name__ == "__main__":
    main()
